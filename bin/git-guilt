#!/usr/bin/env node

var guilt = require('..');
var program = require('commander');
var S = require('string');
var colog = require('colog');
var ProgressBar = require('progress');
var util = require('util');

var packageInfo = require(__dirname + '/../package.json');

program
  .version(packageInfo.version)
  .usage('[options] [<since>] [<until>]\n\t git-guilt [options] [-a|--all] <commit-ish>')
  .option('-e, --email', 'display author emails instead of names')
  .option('-w, --ignore-whitespace', 'ignore whitespace only changes when attributing blame')
  .option('-tty, --force-colored-output', 'Disregard process.stdout.isTTY and colorize output anyway')
  .option('-cmp, --commit-message-path', 'Implies that you want the commit message to have "Suggested reviewers:" added to it.')
  .option('-X, --debug', 'output debug information')
  .option('-a, --at', 'display the total blame for the entire repository tree at a particular commit')
  .option('-b, --batch-size <n>', 'specify the number of concurrent blame operations to run (minimum of 2, defaults to 4)', parseInt)
  .option('-d, --dir <path>', 'force git-guilt to run in the specified directory rather than attempt to detect the repository root');

// turn all options (even unknown --foo-bar-baz) into camel case (opts.fooBarBaz)
program.parse(process.argv);

var opts = { ...program };

console.log('git-guilt opts', opts)

if (opts.debug) {
    opts.logger = console.log;
}

if (opts.dir) {
    opts.repoPath = opts.dir;
}

if (program.at) {
    if (program.args.length === 1) {
        opts.at = program.args[0];
    } else {
        console.error('-a/--at requires a single commit to be specified');
        process.exit(1);
    }
} else {
    switch (program.args.length)
    {
        case 0:
            opts.since = 'HEAD';
            break;
        case 1:
            opts.since = program.args[0];
            break;
        case 2:
            opts.since = program.args[0];
            opts.until = program.args[1];
            break;
        default:
            program.help(); // terminates
    }
}

if (process.stdout.isTTY && !opts.debug) {
    var progressBar;
    opts.onBlameCount = function(count) {
        progressBar = new ProgressBar('Blaming [:bar] :percent :etas', {
            complete: '+',
            incomplete: '-',
            width: 50,
            total: count,
            clear: true
        });
    };
    opts.onBlameComplete = function() {
        progressBar.tick(1);
    };
}

guilt(opts).then(function(guilt) {
    guilt = Object.entries(guilt);
    guilt.sort(function(a, b) {
        return b[1] - a[1];
    });
    var logLines = ''
    guilt.forEach(function(entry) {
        var author = entry[0];
        if (author === 'Not Committed Yet') author = 'Brand new code'
        var loc = entry[1];
        // Guarantees we have 3 spaces on right hand side - but - this could be more dynamic
        author = S(author).truncate(20).padRight(23);
        var locStr;

        if (program.at) {
            locStr = loc;
        } else {
            var maxSymbols = 50;
            var symbol = loc > 0 ? '+' : '-';
            if (Math.abs(loc) > maxSymbols) {
                var elipsis = '(' + loc + ')';
                locStr = S(symbol).repeat(maxSymbols - elipsis.length) + elipsis;
            } else {
                locStr = S(symbol).repeat(Math.abs(loc));
            }
        }

        if (process.stdout.isTTY || opts.forceColoredOutput) {
            logLines += '\n' + author + ' ' + colog.apply(locStr, [loc > 0 ? 'green' : 'red']);
        } else {
            logLines += '\n' + author + ' ' + locStr;
        }
    });
    logLines = logLines.trim()
    console.log(logLines)
    if (opts.commitMessagePath) {
        var prefix = '\n\nSuggested reviewers:\n';
        var msg = opts.currentCommitMessage
        if (msg.includes(commitMsgPrefix)) {
            msg.indexOf(prefix)
            msg = msg.substring(0, 8)
        }
        msg += prefix
        msg += logLines

        fs.writeFileSync(commitMessagePath, msg)
    }
}).catch(function(err) {
    console.error(err);
    process.exit(1);
});

