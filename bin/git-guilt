#!/usr/bin/env node

var guilt = require('..');
var program = require('commander');
var S = require('string');
var colog = require('colog');
var ProgressBar = require('progress');
var _ = require('lodash');
var util = require('util');

var packageInfo = require(__dirname + '/../package.json');

program
  .version(packageInfo.version)
  .usage('[options] [<since>] [<until>]\n\t git-guilt [options] [-a|--all] <commit-ish>')
  .option('-e, --email', 'display author emails instead of names')
  .option('-w, --ignore-whitespace', 'ignore whitespace only changes when attributing blame')
  .option('-d, --debug', 'output debug information')
  .option('-a, --at', 'display the total blame for the tree at a single commit')
  .option('-b, --batch-size <n>', 'specify the number of concurrent blame operations to run (minimum of 2, defaults to 4)', parseInt);

program.parse(process.argv);

var opts = _.extend({}, program);

if (opts.debug) {
    opts.logger = console.log;
} else {
    opts.logger = function() {/*noop*/};
}

if (program.at) {
    if (program.args.length === 1) {
        opts.at = program.args[0];
    } else {
        console.error('-a/--at requires a single commit to be specified');
        process.exit(1);
    }
} else {
    switch (program.args.length)
    {
        case 0:
            opts.since = 'HEAD';
            break;
        case 1:
            opts.since = program.args[0];
            break;
        case 2:
            opts.since = program.args[0];
            opts.until = program.args[1];
            break;
        default:
            program.help(); // terminates
    }
}

if (process.stdout.isTTY) {
    var progressBar;
    opts.onBlameCount = function(count) {
        progressBar = new ProgressBar('Blaming [:bar] :percent :etas', {
            complete: '+',
            incomplete: '-',
            width: 50,
            total: count,
            clear: true
        });
    };
    opts.onBlameComplete = function() {
        progressBar.tick(1);
    };
}

guilt(opts).then(function(guilt) {
    guilt = _.pairs(guilt);
    guilt.sort(function(a, b) {
        return b[1] - a[1];
    });
    guilt.forEach(function(entry) {
        var author = entry[0], loc = entry[1];
        author = S(author).truncate(20).padRight(23);
        var locStr;

        if (program.at) {
            locStr = loc;
        } else {
            var maxSymbols = 50;
            var symbol = loc > 0 ? '+' : '-';
            if (Math.abs(loc) > maxSymbols) {
                var elipsis = '(' + loc + ')';
                locStr = S(symbol).repeat(maxSymbols - elipsis.length) + elipsis;
            } else {
                locStr = S(symbol).repeat(Math.abs(loc));
            }
        }

        if (process.stdout.isTTY) {
            console.log(author + ' ' + colog.apply(locStr, [loc > 0 ? 'green' : 'red']));
        } else {
            console.log(author + ' ' + locStr);
        }
    });
}).catch(function(err) {
    console.error(err);
    process.exit(1);
});

