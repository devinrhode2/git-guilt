#!/usr/bin/env node

var util = require('util');
var _ = require('lodash');
var program = require('commander');
var byline = require('byline');
var S = require("string");

var packageInfo = require('./package.json');

program
  .version(packageInfo.version)
  .usage('[<options>] <since>  <until>')
  .option('-d, --debug', 'Output debug information');

program.parse(process.argv)

var debug = program.debug ? console.log : function() {/* no-op */};

var _spawn = require('child_process').spawn;
var spawn = program.debug ? function() {
    debug("spawn:", arguments[0], arguments[1].join(' '));
    return _spawn.apply(this, arguments);
} : _spawn;

var since, until;

switch (program.args.length) {
    case 0:
        since = 'HEAD';
        until = '';
        break;
    case 1:
        since = program.args[0];
        until = '';
        break;
    case 2:
        since = program.args[0];
        until = program.args[1];
        break;
    default:
        program.help(); // terminates
}

var blameRx = /[0-9a-f]+ \((.*) \d{4}-\d{2}-\d{2}/;

var blamesNeeded = 0, blamesRun = 0;

var blame = {
    since: {},
    until: {}
}; 

function blameComplete() {
    debug("All blames complete!");
    debug(util.inspect(blame, {depth: 3}));

    var locDeltas = [];
    _.each(blame.until, function(newCount, author) {
        var locDelta = newCount - (blame.since[author] || 0);
        if (locDelta) {
            locDeltas.push({author: author, delta: locDelta});
        }
    });
    locDeltas.sort(function(a, b) {
        if (a.delta < b.delta) {
            return 1;
        }
        if (a.delta > b.delta) {
            return -1;
        }
        return 0;
    });    
    _.each(locDeltas, function(entry) {
        var author = S(entry.author).truncate(20).padRight(20);
        var deltaStr;
        var maxSymbols = 80;

        if (Math.abs(entry.delta) > maxSymbols) {
            var elipsis = "(" + entry.delta + ")";
            deltaStr = S(entry.delta > 0 ? "+" : "-").repeat(maxSymbols - elipsis.length) + elipsis;
        } else {
            deltaStr = S(entry.delta > 0 ? "+" : "-").repeat(Math.abs(entry.delta));
        }
            
        console.log(author + " " + deltaStr);
    });
}

function repeatStr(str, n) {
    var newStr = "";
    while (--n > 0) {
        newStr += str;
    }
    return newStr;
}

function tabulateBlame(blameBucket, path, rev) {
    var blameArgs = ['blame', '--', path];
    if (rev) blameArgs.splice(1, 0, rev);
    var gitBlame = spawn('git', blameArgs);
    var blameStream = byline(gitBlame.stdout);

    blameStream.on('data', function(line) {
        var match = blameRx.exec(line);
        if (match) {
            var author = match[1].trim();
            var value = blameBucket[author];
            blameBucket[author] = (value ? value : 0) + 1;
        }
    });

    gitBlame.on('exit', function(code) {
        debug('git blame (' + path + ' @ ' + (rev ? rev : 'working copy') + ') exited with ' + code);
        blamesRun++; 
        debug(blamesRun + "/" + blamesNeeded + " blames complete");
        if (blamesRun >= blamesNeeded) {            
            blameComplete();
        }
    });
}

// resolve changed files
var diffArgs = ['diff', '--name-only', since];
if (until) diffArgs.push(until);
var gitDiff = spawn('git', diffArgs);
var diffStream = byline(gitDiff.stdout);

diffStream.on('data', function(line) {    
    debug('changed: ' + line);
    blamesNeeded += 2;
    tabulateBlame(blame.since, line, since);
    tabulateBlame(blame.until, line, until);
});

gitDiff.on('exit', function(code) {
    debug('git diff exited with ' + code);
});